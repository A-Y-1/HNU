-----------------------------------------------------------------------------------------------
02casar密码
getchar();getline(cin,code);getchar();
if(90=>a[i]>=65);
if(a[i]-5<65) a[i]=a[i]+26-5;
else a[i]-=5;
02身份证校验码
map<int,char> {{},{},......};
02组个最小数
for(int i=0;i<count+1;i++)
{
	result+=x[i];
	if(result[0]=='0') 
	{
		result[0]=x[i][0];
		result[i]='0';
	}
}
-----------------------------------------------------------------------------------------------
03分数排序
2个排序规则
如果和前一名分数相等则排名也和上一位相等
否则排名++
-----------------------------------------------------------------------------------------------
03蛇形矩阵
y 的初值为1，x的初值为0，每输出完一行x++
两个步长数组stepy stepx
-----------------------------------------------------------------------------------------------
03相同生日
node 结构体保存生日
排序后遍历
和前一个相等和后一个不相等 输出id换行
和前一个相等和后一个相等 输出id+空格
不等于前一个等于后一个 输出日期+id+空格
else 输出信息后换行
-----------------------------------------------------------------------------------------------
03疫情期间
dp[1000][3] 数组
初始化dp[0][]=0
从第一天开始动态更新
输出第n天的最小结果
-----------------------------------------------------------------------------------------------
03数塔
两个二维数组，一个记录数塔，一个记录最大和，开n+1
最后一行的最大和初始化为数塔底层
从倒数第二层第一个数字开始更新，判断tower[i][j]+maxsum[i+1][j]/maxsum[i+1][j+1]的大小
输出maxsum[1][1]
输出tower[1][1]
int j=1
从i=2开始，temp=上一层maxsum-上一层数塔的值
如果temp和该层的maxsum【i】【j+1】相等，j++
输出tower【i】【j】
-----------------------------------------------------------------------------------------------
03小希的数表
while
读入sum数据
排序
for遍历，i=3开始枚举num2+num3
num1=(sum1+sum2-sumi)/2
初始化vis数组
visi=1
flag=true
start=3
for循环从4开始且flag=true
while(visstart) ++start
visstart=1
numj=sumstart-num1
排除
for k k<j flag=true
for p=start+1
flag=fasle
如果没访问过且numk+numj=sump
visp
flag=true
break
-----------------------------------------------------------------------------------------------
03日历问题
用数组表示年份天数和月份天数
whilenum>year[isleapyear(tyear)]
-----------------------------------------------------------------------------------------------
04相等的多项式
三个数组，num,res,given
res0即常数初始化为num1
res1=1 最大次项系数为一
 从2开始遍历
系数为1
遍历比i小的项
resj=resj*numi+res[j-1]
res[0]*=num[i]
检查结果是否正确
-----------------------------------------------------------------------------------------------
04最小钱币数
两个数组，一个为硬币面额，一个dp数组，给dp初始化
遍历dp
遍历硬币dp[i]=min(dp[i-coin[j]]+1,dp[i]);
-----------------------------------------------------------------------------------------------
04回文串
从开头开始截取字符串
用reverse取反+到源字符后check是否为回文串